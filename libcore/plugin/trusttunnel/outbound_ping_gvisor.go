//go:build with_gvisor

package trusttunnel

import (
	"bytes"
	"context"
	"net/netip"
	"sync"
	"sync/atomic"
	"time"

	"github.com/sagernet/gvisor/pkg/tcpip"
	"github.com/sagernet/gvisor/pkg/tcpip/checksum"
	"github.com/sagernet/gvisor/pkg/tcpip/header"
	"github.com/sagernet/sing-box/adapter"
	"github.com/sagernet/sing-box/log"
	"github.com/sagernet/sing-tun"
	"github.com/sagernet/sing/common/buf"
	E "github.com/sagernet/sing/common/exceptions"

	"github.com/xchacha20-poly1305/sing-trusttunnel"
)

const withGvisor = true

// Generated by codex.

func (h *Outbound) NewDirectRouteConnection(metadata adapter.InboundContext, routeContext tun.DirectRouteContext, timeout time.Duration) (tun.DirectRouteDestination, error) {
	ctx := log.ContextWithNewID(h.ctx)
	icmpConn, err := h.client.ListenICMP(ctx)
	if err != nil {
		return nil, err
	}
	pinger := &pingAdapter{
		ctx:          ctx,
		logger:       h.logger,
		routeContext: routeContext,
		source:       metadata.Source.Addr,
		destination:  metadata.Destination.Addr,
		timeout:      timeout,
		requests:     make(map[pingRequest]pingRequestData),
		IcmpConn:     icmpConn,
	}
	go pinger.loopRead()
	h.logger.InfoContext(ctx, "linked ", metadata.Network, " connection from ", metadata.Source.AddrString(), " to ", metadata.Destination.AddrString())
	return pinger, nil
}

var _ tun.DirectRouteDestination = (*pingAdapter)(nil)

type pingAdapter struct {
	isClosed      atomic.Bool
	ctx           context.Context
	logger        log.ContextLogger
	routeContext  tun.DirectRouteContext
	source        netip.Addr
	destination   netip.Addr
	timeout       time.Duration
	requestAccess sync.Mutex
	requests      map[pingRequest]pingRequestData
	*trusttunnel.IcmpConn
}

func (p *pingAdapter) WritePacket(packet *buf.Buffer) error {
	data := packet.Bytes()
	ipVersion := header.IPVersion(data)
	switch ipVersion {
	case header.IPv4Version:
		ipHdr := header.IPv4(data)
		if !ipHdr.IsValid(packet.Len()) {
			return E.New("invalid IPv4 header")
		}
		if ipHdr.TransportProtocol() != header.ICMPv4ProtocolNumber {
			return E.New("invalid ICMPv4 protocol")
		}
		if ipHdr.PayloadLength() < header.ICMPv4MinimumSize {
			return E.New("invalid ICMPv4 header")
		}
		icmpHdr := header.ICMPv4(ipHdr.Payload())
		if icmpHdr.Type() != header.ICMPv4Echo {
			return E.New("unsupported ICMPv4 type: ", icmpHdr.Type())
		}
		payload := bytes.Clone(icmpHdr.Payload())
		p.registerRequest(false, icmpHdr.Ident(), icmpHdr.Sequence(), payload)
		return p.IcmpConn.WritePing(icmpHdr.Ident(), p.destination, icmpHdr.Sequence(), ipHdr.TTL(), uint16(len(payload)))
	case header.IPv6Version:
		ipHdr := header.IPv6(data)
		if !ipHdr.IsValid(packet.Len()) {
			return E.New("invalid IPv6 header")
		}
		if ipHdr.TransportProtocol() != header.ICMPv6ProtocolNumber {
			return E.New("invalid ICMPv6 protocol")
		}
		if ipHdr.PayloadLength() < header.ICMPv6MinimumSize {
			return E.New("invalid ICMPv6 header")
		}
		icmpHdr := header.ICMPv6(ipHdr.Payload())
		if icmpHdr.Type() != header.ICMPv6EchoRequest {
			return E.New("unsupported ICMPv6 type: ", icmpHdr.Type())
		}
		payload := bytes.Clone(icmpHdr.Payload())
		p.registerRequest(true, icmpHdr.Ident(), icmpHdr.Sequence(), payload)
		return p.IcmpConn.WritePing(icmpHdr.Ident(), p.destination, icmpHdr.Sequence(), ipHdr.HopLimit(), uint16(len(payload)))
	default:
		return E.New("invalid IP version ", ipVersion)
	}
}

func (p *pingAdapter) Close() error {
	p.isClosed.Store(true)
	return p.IcmpConn.Close()
}

func (p *pingAdapter) IsClosed() bool {
	return p.isClosed.Load()
}

type pingRequest struct {
	id     uint16
	seq    uint16
	isIPv6 bool
}

type pingRequestData struct {
	payload []byte
	created time.Time
}

func (p *pingAdapter) registerRequest(isIPv6 bool, id uint16, seq uint16, payload []byte) {
	const requestsLimit = 1024
	now := time.Now()
	key := pingRequest{id: id, seq: seq, isIPv6: isIPv6}
	p.requestAccess.Lock()
	defer p.requestAccess.Unlock()
	var (
		oldestKey  pingRequest
		oldestTime = now
	)
	for request, data := range p.requests {
		if now.Sub(data.created) > p.timeout {
			delete(p.requests, request)
			continue
		}
		if data.created.Before(oldestTime) {
			oldestKey = request
			oldestTime = data.created
		}
	}
	if len(p.requests) >= requestsLimit {
		delete(p.requests, oldestKey)
	}
	p.requests[key] = pingRequestData{payload: payload, created: now}
}

func (p *pingAdapter) popRequest(isIPv6 bool, id uint16, seq uint16) ([]byte, bool) {
	key := pingRequest{id: id, seq: seq, isIPv6: isIPv6}
	p.requestAccess.Lock()
	defer p.requestAccess.Unlock()
	data, loaded := p.requests[key]
	if loaded {
		delete(p.requests, key)
		return data.payload, true
	}
	return nil, false
}

func (p *pingAdapter) loopRead() {
	defer p.Close()
	for {
		id, source, icmpType, code, sequence, err := p.ReadPing()
		if err != nil {
			if p.IsClosed() || E.IsClosed(err) {
				return
			}
			p.logger.ErrorContext(p.ctx, E.Cause(err, "receive ICMP echo reply"))
			return
		}
		if !source.IsValid() || !p.source.IsValid() {
			continue
		}
		if source.Is6() {
			if header.ICMPv6Type(icmpType) != header.ICMPv6EchoReply {
				continue
			}
			payload, loaded := p.popRequest(true, id, sequence)
			if !loaded {
				continue
			}
			reply := buildICMPv6Reply(source, p.source, header.ICMPv6Type(icmpType), header.ICMPv6Code(code), id, sequence, payload)
			if reply == nil {
				continue
			}
			err = p.routeContext.WritePacket(reply.Bytes())
			reply.Release()
			if err != nil {
				p.logger.ErrorContext(p.ctx, E.Cause(err, "write ICMPv6 echo reply"))
			}
		} else {
			if header.ICMPv4Type(icmpType) != header.ICMPv4EchoReply {
				continue
			}
			payload, loaded := p.popRequest(false, id, sequence)
			if !loaded {
				continue
			}
			reply := buildICMPv4Reply(source, p.source, header.ICMPv4Type(icmpType), header.ICMPv4Code(code), id, sequence, payload)
			if reply == nil {
				continue
			}
			err = p.routeContext.WritePacket(reply.Bytes())
			reply.Release()
			if err != nil {
				p.logger.ErrorContext(p.ctx, E.Cause(err, "write ICMPv4 echo reply"))
			}
		}
	}
}

func buildICMPv4Reply(src, dst netip.Addr, icmpType header.ICMPv4Type, code header.ICMPv4Code, id uint16, seq uint16, payload []byte) *buf.Buffer {
	if !src.Is4() || !dst.Is4() {
		return nil
	}
	icmpLen := header.ICMPv4MinimumSize + len(payload)
	totalLen := header.IPv4MinimumSize + icmpLen
	packet := buf.NewSize(totalLen)
	data := packet.Extend(totalLen)
	ipHdr := header.IPv4(data)
	ipHdr.Encode(&header.IPv4Fields{
		TotalLength: uint16(totalLen),
		TTL:         64,
		Protocol:    uint8(header.ICMPv4ProtocolNumber),
		SrcAddr:     tcpip.AddrFrom4(src.As4()),
		DstAddr:     tcpip.AddrFrom4(dst.As4()),
	})
	ipHdr.SetChecksum(^ipHdr.CalculateChecksum())
	icmpHdr := header.ICMPv4(data[header.IPv4MinimumSize:])
	icmpHdr.SetType(icmpType)
	icmpHdr.SetCode(code)
	icmpHdr.SetIdent(id)
	icmpHdr.SetSequence(seq)
	copy(icmpHdr.Payload(), payload)
	icmpHdr.SetChecksum(0)
	icmpHdr.SetChecksum(header.ICMPv4Checksum(icmpHdr, checksum.Checksum(payload, 0)))
	return packet
}

func buildICMPv6Reply(src, dst netip.Addr, icmpType header.ICMPv6Type, code header.ICMPv6Code, id uint16, seq uint16, payload []byte) *buf.Buffer {
	if !src.Is6() || !dst.Is6() {
		return nil
	}
	icmpLen := header.ICMPv6MinimumSize + len(payload)
	totalLen := header.IPv6MinimumSize + icmpLen
	packet := buf.NewSize(totalLen)
	data := packet.Extend(totalLen)
	ipHdr := header.IPv6(data)
	ipHdr.Encode(&header.IPv6Fields{
		PayloadLength:     uint16(icmpLen),
		TransportProtocol: header.ICMPv6ProtocolNumber,
		HopLimit:          64,
		SrcAddr:           tcpip.AddrFrom16(src.As16()),
		DstAddr:           tcpip.AddrFrom16(dst.As16()),
	})
	icmpHdr := header.ICMPv6(data[header.IPv6MinimumSize:])
	icmpHdr.SetType(icmpType)
	icmpHdr.SetCode(code)
	icmpHdr.SetIdent(id)
	icmpHdr.SetSequence(seq)
	copy(icmpHdr.Payload(), payload)
	icmpHdr.SetChecksum(0)
	icmpHdr.SetChecksum(header.ICMPv6Checksum(header.ICMPv6ChecksumParams{
		Header: icmpHdr,
		Src:    ipHdr.SourceAddress(),
		Dst:    ipHdr.DestinationAddress(),
	}))
	return packet
}
